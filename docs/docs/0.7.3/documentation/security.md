# Security

There are several communication use cases that can be secured when using Kuma.

## Data plane to data plane communication

Kuma helps you secure your existing infrastructure with mTLS.

### Mutual TLS

Once a data plane has proved its identity to the control plane, it will be allowed to fetch its own identity certificate and a root CA certificate of the mesh.
When establishing a connection between two data planes, each side validates the other data plane's certificate using the root CA of the mesh, which then confirms their identity.

mTLS is _not_ enabled by default. To enable it, apply proper settings in [Mesh](../../policies/mesh) policy.
Additionally, when running on Universal you have to ensure that every data plane in the mesh has been configured with a Dataplane Token.

When mTLS is enabled, every connection between data planes is denied by default, so you have to explicitly allow it using [TrafficPermission](../../policies/traffic-permissions).

### Certificates

Kuma uses a built-in CA (Certificate Authority) to issue certificates for data planes. The root CA certificate is unique for each mesh
in the system. On Kubernetes, the root CA certificate is stored as a [Kubernetes Secret](https://kubernetes.io/docs/concepts/configuration/secret/).
On Universal, we leverage the same storage (Postgres) that is used for storing policies.
Certificates for data planes are ephemeral, re-created on dataplane restart, and never persisted on disk.

Dataplane certificates generated by Kuma are X.509 certificates that are [SPIFFE](https://github.com/spiffe/spiffe/blob/master/standards/X509-SVID.md) compliant. The SAN of certificate is set to `spiffe://<mesh name>/<service name>`

Kuma also supports other CAs. For further details refer to [Mutual TLS](../../policies/mutual-tls) policy.

## Data plane to control plane communication

A data plane connects to the control plane for its configuration, including mTLS certificates described in the previous sections.

### Encrypted communication

Because the data plane and the control plane exchange sensitive information, the communication needs to be encrypted by TLS.
By default, the control plane's server that is consumed by the data plane is secured by TLS with autogenerated certificates.

For security purposes, the data plane must verify the identity of the control plane. To do so, data planes need to obtain the CA that was used to generate the certificate by which the control plane's server is secured.
Note, this CA is not the same CA for data plane to data plane communication.

:::: tabs :options="{ useUrlFragment: false }"
::: tab "Kubernetes"
To override autogenerated certificates:
1) Create a secret in the namespace in which Control Plane is installed
```sh
kubectl create secret generic general-tls-certs -n kuma-system \
  --from-file=tls.crt=/path/to/cert \
  --from-file=tls.key=/path/to/key \
  --from-file=ca.crt=/path/to/key
```

2) Point to this secret when installing Kuma
* `kumactl install control-plane --tls-general-secret=general-tls-certs --tls-general-ca-bundle=<BASE64 content of ca.crt>` via kumactl
* Set `controlPlane.tls.general.secretName` to `general-tls-certs` and `controlPlane.tls.general.caBundle` to `<BASE64 content of ca.crt>` via HELM

The Dataplane Injector builtin in the control plane automatically provides the CA to the Kuma DP sidecar.
:::
::: tab "Universal"
To override autogenerated certificates set the following configuration
* `KUMA_DP_SERVER_TLS_CERT_FILE` - path to a certificate
* `KUMA_DP_SERVER_TLS_KEY_FILE` - path to a key

Provide the CA that was used to sign certs above by using `--ca-cert-file=/path/ca-cert.pem` or via environment variable `KUMA_CONTROL_PLANE_CA_CERT` when starting the `kuma-dp` process.
::: 
::::

### Dataplane Authentication

In order to obtain an mTLS certificate from the server ([SDS](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret) built-in in the control plane), a data plane must authenticate itself.

:::: tabs :options="{ useUrlFragment: false }"

::: tab "Kubernetes (Service Account Token)"
On Kubernetes, a data plane proves its identity by leveraging [ServiceAccountToken](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#service-account-automation) that is mounted in every pod.
:::

::: tab "Universal (Dataplane Token)"

On Universal, a data plane must be explicitly configured with a security token (Dataplane Token) that will be used to prove its identity.
Dataplane Token is a signed [JWT token](https://jwt.io) that carries data of the data plane that is allowed to join the mesh.
It is signed by an RSA key auto-generated by the control plane on the first run. Tokens are not stored in the control plane,
the only thing that is stored is a signing key that is used for token verification and generation. 

You can generate token either by REST API
```bash
curl -XPOST \ 
  -H "Content-Type: application/json" \
  --data '{"name": "dp-echo-1", "mesh": "default", "tags": {"kuma.io/service": ["backend", "backend-admin"]}}' \
  http://localhost:5681/tokens
```

or by using `kumactl`
```bash
kumactl generate dataplane-token \
  --name dp-echo-1 \
  --mesh default \
  --tag kuma.io/service=backend,backend-admin > /tmp/kuma-dp-echo1-token
``` 

The token should be stored in a file and then used when starting `kuma-dp`
```bash
$ kuma-dp run \
  --name=dp-echo-1 \
  --mesh=default \
  --cp-address=https://127.0.0.1:5678 \
  --dataplane-token-file=/tmp/kuma-dp-echo-1-token
```

You can also pass Dataplane Token as `KUMA_DATAPLANE_RUNTIME_TOKEN` Environment Variable. 

#### Dataplane Token boundary

As you can see in the example above, you can generate a token by passing name, mesh, and tags. Control Plane will verify Dataplane against data available in the Token. This means you can generate a token by specifying:
* only `mesh`. This way you can reuse the token for all data planes in a given mesh.
* `mesh` + `tag` (ex. `kuma.io/service`). This way you can use one token across all instances of given service.
  Keep in mind that you have to specify all the values. If you have a Dataplane with 2 inbounds, one with `kuma.io/service: backend` and one with `kuma.io/service: backend-admin`, you need to specify both values (`--tag kuma.io/service=backend,backend-admin`).
* `mesh` + `name` + `tag` (ex. `kuma.io/service`). This way you can use one token for one instance of given service.

:::
::: tab "Off"
You can turn off authentication for testing proposes. Set `KUMA_DP_SERVER_AUTH_TYPE` to `none`.

::: warning
If you turn off authentication, any dataplane can request certificate for any service, therefore this should not be used in a production setup.
:::
::::

#### Multizone

When running in multizone, mode you can generate Dataplane Tokens both on Global and Remote Control Plane.
If you configure your deployment pipeline to generate Dataplane Token before running a data plane you can use Remote CP. This way Global CP is not a single point of failure.

## User to control plane communication

Users and automation tools can interact with the control plane via the API Server using tools like `curl` or `kumactl`.
API Server by default is exposed on `:5681` on HTTP and `:5682` on HTTPS.

### Encrypted communication

API Server HTTPS server is secured by default by autogenerated certificates. You can override those certificates.

:::: tabs :options="{ useUrlFragment: false }"
::: tab "Kubernetes"
To override autogenerated certificates:
1) Create a secret in the namespace in which Control Plane is installed
```sh
kubectl create secret tls api-server-tls -n kuma-system \
  --cert=/root/test-certs/cert.pem \
  --key=/root/test-certs/key.pem
```
2) Point to this secret when installing Kuma
* `kumactl install control-plane --tls-api-server-secret=api-server-tls` via kumactl
* Set `controlPlane.tls.apiServer.secretName` to `api-server-tls` via HELM
:::
::: tab "Universal"
To override autogenerated certificates set the following configuration
* `KUMA_API_SERVER_HTTPS_TLS_CERT_FILE` - path to a certificate
* `KUMA_API_SERVER_HTTPS_TLS_KEY_FILE` - path to a key
::: 
::::

You can then configure secure connection using kumactl
```sh
kumactl config control-planes add \
  --name <NAME> \
  --address https://<KUMA_CP_DNS_NAME>:5682 \
  --ca-cert-file <CA.PEM> \
```

You can also hide the HTTP version of API Server by binding it to localhost `KUMA_API_SERVER_HTTP_INTERFACE: 127.0.0.1` or by disabling it altogether `KUMA_API_SERVER_HTTP_ENABLED: false`

### Authentication

Some endpoints like managing Secrets or generating Dataplane Tokens require authentication. To access those endpoints in two ways

#### Request originating from localhost

For simplicity of use, requests that are originating from the same machine as CP are authenticated. You can disable this behavior by setting `KUMA_API_SERVER_AUTH_ALLOW_FROM_LOCALHOST` to `false`

::: tip
On Kubernetes, you can port-forward 5681 port and access the admin endpoints.
:::

#### Client certificates

When accessing admin endpoints from a different machine you need to use client certificates.

1) Generate client certificates by using kumactl
```sh
$ kumactl generate tls-certificate --type=client \
  --cert-file=/path/to/cert \
  --key-file=/path/to/key
```
2) Configure control plane with client certificates
:::: tabs :options="{ useUrlFragment: false }"
::: tab "Kubernetes"
1) Create a secret in the namespace in which Control Plane is installed
```sh
$ kubectl create secret generic api-server-client-certs -n kuma-system \
  --from-file=client1.pem=/path/to/cert/cert1.pem \
  --from-file=client2.pem=/path/to/cert/cert2.pem
```
You can provide as many client certs as you want. Remember to only put there certificates without keys.

2) Point to this secret when installing Kuma
* `kumactl install control-plane tls-api-server-client-certs-secret=api-server-client-certs` via kumactl
* Set `controlPlane.tls.apiServer.clientCertsSecretName` to `api-server-client-certs` via HELM
:::
::: tab "Universal"
1) Put all the certificates in one directory
2) Configure control plane by pointing to this directory `KUMA_API_SERVER_AUTH_CLIENT_CERTS_DIR`
:::
::::

3) Configure kumactl with client certificates
```sh
$ kumactl config control-planes add \
  --name <NAME> --address https://<KUMA_CP_DNS_NAME>:5682 \
  --client-cert-file <CERT.PEM> \
  --client-key-file <KEY.PEM> \
  --ca-cert-file <CA.PEM>
```

## Control plane to Postgres communication

Since on Universal, the secrets such as "provided" CA's private key, are stored in Postgres, a connection between Postgres and Kuma CP should be secured with TLS.
To secure the connection, first pick the security mode using `KUMA_STORE_POSTGRES_TLS_MODE`. There are several modes:
* `disable` - is not secured with TLS (secrets will be transmitted over network in plain text).
* `verifyNone` - the connection is secured but neither hostname, nor by which CA the certificate is signed is checked.
* `verifyCa` - the connection is secured and the certificate presented by the server is verified using the provided CA.
* `verifyFull` - the connection is secured, certificate presented by the server is verified using the provided CA and server hostname must match the one in the certificate.

The CA for verification server's certificate can be set using `KUMA_STORE_POSTGRES_TLS_CA_PATH`.

Once secured connections are configured in Kuma CP, you have to configure Postgres' [`pg_hba.conf`](https://www.postgresql.org/docs/9.1/auth-pg-hba-conf.html) file to restrict unsecured connections.
Here is an example configuration that will allow only TLS connections and will require username and password:
```
# TYPE  DATABASE        USER            ADDRESS                 METHOD
hostssl all             all             0.0.0.0/0               password
```
 
You can also provide client key and certificate for mTLS using `KUMA_STORE_POSTGRES_TLS_CERT_PATH` and `KUMA_STORE_POSTGRES_TLS_KEY_PATH`.
This pair can be used for auth-method `cert` described [here](https://www.postgresql.org/docs/9.1/auth-pg-hba-conf.html).
